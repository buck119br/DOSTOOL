Byte读取方式的代码过程

	像Byte数据的读取过程比较简单，仍然强调HST_STS的变化，如前面一段英文描述，命名是否成功结束可以用INTR位来得到，命名执行失败可以通过HST_STS&1CH是否为0来判断（也就是各种错误标志位）。

   第一步：通过HST_STS判断SMBus是否空闲可用(HST_STS&1EH==0？不为0则1EH=>HST_STS。HST_STS&01H==0?不为0则循环)
   第二步：设置XMIT_SLVA (SMBA+04h), 选择设备地址，以及读写设为01h
   第三步：设置HST_CMD（SMBASE+03h),选择设备对应的Register Index
   第四步：设置HST_CNT（SMBASE+02h)，写48h表Byte Data形式读取
   第五步：循环判断HST_STS(HST_STS&1CH不为0则报错，HOST_BUSY应为0且INTR应为1否则循环)
   第六步：从HST_D0(SMBASE+05h)中读取数据




;[]============================[]
;Input     : CL - register index
;        CH - device ID
;Output : AL - Value read
;[]============================[]

Smbus_ReadByte    Proc    Near

     Push          cx       ;保存cx

     	mov      dx,05000h     ;SMBus Base address，在我的C器上的
     	mov      dl,04h        ；xTransmit Slave Address
     	or       ch，01h       ;read x
     	mov      al,ch         ;ID cmd(read)
     	out      dx,al

     	IODELAY

     	call     Chk_SMBus_Ready   ；如SMbus不ok就一直停在@Y，直到超^定的rg，如果SMbus不ok那N就箦e。

    	pop      ax                ；恢cx到ax中
     	mov      dl,03h          ；xHost Command Register
     	out      dx,al            ；把要x取的寄存器index送出去

     	IODELAY

     	mov      dl,02h          ；xHost Control Register
     	mov      al,48h          ；下命令_始x取by Byte Data:
     	out      dx,al            ；Read data

     	IODELAY

      	mov      cx, 100h

@@:               

     	IODELAY            

     	loop     short @B      ；@Y@圈是榱俗smbus浜枚加的延r

     	call     Chk_SMBus_Ready

     	mov      dl,05            ；xHost Data 0 Register
     	in       al,dx            ；Data0

	IODELAY

	ret